{
  "address": "0x143478c3e027dd1d1C04c2732BDbF6e9BF0CB21e",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "uploader",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "Anchored",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "hashes",
          "type": "bytes32[]"
        }
      ],
      "name": "anchorBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        }
      ],
      "name": "anchorRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "fileHash",
          "type": "bytes32"
        }
      ],
      "name": "anchorSingle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        }
      ],
      "name": "getAnchor",
      "outputs": [
        {
          "internalType": "address",
          "name": "uploader",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "leaf",
          "type": "bytes32"
        }
      ],
      "name": "verifyInclusion",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x4060bbcc35f53c620b46369d48345da234159e476cd8aa703ffe648261cdc6f7",
  "receipt": {
    "to": null,
    "from": "0x0Ad9AAbda8c58245ADcc01a212d7a901e55381Bf",
    "contractAddress": "0x143478c3e027dd1d1C04c2732BDbF6e9BF0CB21e",
    "transactionIndex": 44,
    "gasUsed": "665544",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfe59ddfacefd60051b12cec985c9f75dcd6fe157f24e797e061174d7dc570179",
    "transactionHash": "0x4060bbcc35f53c620b46369d48345da234159e476cd8aa703ffe648261cdc6f7",
    "logs": [],
    "blockNumber": 23148771,
    "cumulativeGasUsed": "7912236",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "4e609fc87596c2354046df7c7c940a62",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"uploader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Anchored\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"anchorBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"anchorRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"fileHash\",\"type\":\"bytes32\"}],\"name\":\"anchorSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"getAnchor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"uploader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"verifyInclusion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"FileAnchor\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"anchorBatch(bytes32[])\":{\"notice\":\"Anchor multiple hashes (leaves or roots) in one tx\"},\"anchorRoot(bytes32)\":{\"notice\":\"Anchor a Merkle root computed off-chain\"},\"anchorSingle(bytes32)\":{\"notice\":\"Anchor a single file-hash (keccak256 of the file)\"},\"getAnchor(bytes32)\":{\"notice\":\"Get who and when a hash/root was anchored\"},\"verifyInclusion(bytes32[],bytes32,bytes32)\":{\"notice\":\"Verifies that a leaf is in an anchored Merkle root\"}},\"notice\":\"Anchor single file hashes or Merkle roots on-chain, and verify inclusion proofs.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FileAnchor.sol\":\"FileAnchor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/Hashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library of standard hash functions.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Hashes {\\n    /**\\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\\n     *\\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n     */\\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8cbd338f083224b4b6f0ff42cbda641a0a6c31ffcdca197452b97fe4d0918269\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Hashes} from \\\"./Hashes.sol\\\";\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n *\\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\\n * that access memory in an unsafe way.\\n *\\n * NOTE: This library supports proof verification for merkle trees built using\\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\\n * leaf inclusion in trees built using non-commutative hashing functions requires\\n * additional logic that is not supported by this library.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with the default hashing function.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProof(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in memory with a custom hashing function.\\n     */\\n    function processProof(\\n        bytes32[] memory proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with the default hashing function.\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processProofCalldata(proof, leaf, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leaves & pre-images are assumed to be sorted.\\n     *\\n     * This version handles proofs in calldata with a custom hashing function.\\n     */\\n    function processProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 leaf,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = hasher(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProof}.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in memory with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with the default hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * This version handles multiproofs in calldata with a custom hashing function.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\\n     * validating the leaves elsewhere.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves,\\n        function(bytes32, bytes32) view returns (bytes32) hasher\\n    ) internal view returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofFlagsLen = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = hasher(a, b);\\n        }\\n\\n        if (proofFlagsLen > 0) {\\n            if (proofPos != proof.length) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[proofFlagsLen - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x36a0c409c437a753cac9b92b75f93b0fbe92803bf2c8ff1517e54b247f166134\",\"license\":\"MIT\"},\"contracts/FileAnchor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\n/// @title FileAnchor\\n/// @notice Anchor single file hashes or Merkle roots on-chain, and verify inclusion proofs.\\ncontract FileAnchor {\\n    struct AnchorData {\\n        address uploader;\\n        uint256 blockNumber;\\n        uint256 timestamp;\\n    }\\n\\n    // bytes32 \\u2192 who anchored it, when\\n    mapping(bytes32 => AnchorData) private _anchors;\\n\\n    event Anchored(\\n        address indexed uploader,\\n        bytes32 indexed dataHash,\\n        uint256 blockNumber,\\n        uint256 timestamp\\n    );\\n\\n    /// @notice Anchor a single file-hash (keccak256 of the file)\\n    function anchorSingle(bytes32 fileHash) external {\\n        _anchor(fileHash);\\n    }\\n\\n    /// @notice Anchor a Merkle root computed off-chain\\n    function anchorRoot(bytes32 merkleRoot) external {\\n        _anchor(merkleRoot);\\n    }\\n\\n    /// @notice Anchor multiple hashes (leaves or roots) in one tx\\n    function anchorBatch(bytes32[] calldata hashes) external {\\n        uint256 blk = block.number;\\n        uint256 ts  = block.timestamp;\\n        for (uint i = 0; i < hashes.length; i++) {\\n            bytes32 h = hashes[i];\\n            if (h != bytes32(0) && _anchors[h].uploader == address(0)) {\\n                _anchors[h] = AnchorData(msg.sender, blk, ts);\\n                emit Anchored(msg.sender, h, blk, ts);\\n            }\\n        }\\n    }\\n\\n    /// @notice Verifies that a leaf is in an anchored Merkle root\\n    function verifyInclusion(\\n        bytes32[] calldata proof,\\n        bytes32  root,\\n        bytes32  leaf\\n    ) external pure returns (bool) {\\n        return MerkleProof.verify(proof, root, leaf);\\n    }\\n\\n    /// @notice Get who and when a hash/root was anchored\\n    function getAnchor(bytes32 dataHash)\\n        external\\n        view\\n        returns (\\n            address uploader,\\n            uint256 blockNumber,\\n            uint256 timestamp\\n        )\\n    {\\n        AnchorData memory info = _anchors[dataHash];\\n        require(info.uploader != address(0), \\\"FileAnchor: not anchored\\\");\\n        return (info.uploader, info.blockNumber, info.timestamp);\\n    }\\n\\n    // --- internal helper ---\\n    function _anchor(bytes32 h) private {\\n        require(h != bytes32(0), \\\"FileAnchor: invalid hash\\\");\\n        require(_anchors[h].uploader == address(0), \\\"FileAnchor: already anchored\\\");\\n\\n        _anchors[h] = AnchorData(msg.sender, block.number, block.timestamp);\\n        emit Anchored(msg.sender, h, block.number, block.timestamp);\\n    }\\n}\",\"keccak256\":\"0x73c0df6ec867ce5e7776c9482cc150a035401a706cc09dfe9d074168b0ad0482\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50610b1c8061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806349a359f71461005c57806373d2a9e61461008c5780637feb51d9146100a8578063c50b037b146100da578063d5ce53d5146100f6575b600080fd5b61007660048036038101906100719190610784565b610112565b6040516100839190610813565b60405180910390f35b6100a660048036038101906100a1919061082e565b61016a565b005b6100c260048036038101906100bd919061087b565b610321565b6040516100d193929190610902565b60405180910390f35b6100f460048036038101906100ef919061087b565b610440565b005b610110600480360381019061010b919061087b565b61044c565b005b6000610160858580806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050508484610458565b9050949350505050565b6000439050600042905060005b8484905081101561031a57600085858381811061019757610196610939565b5b9050602002013590506000801b81141580156102145750600073ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b1561030c5760405180606001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018481525060008083815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155905050803373ffffffffffffffffffffffffffffffffffffffff167ffdb3bf667beac2c2ec43eb46591be8a61f3426d05a1e30c8a59ff6608bab00888686604051610303929190610968565b60405180910390a35b508080600101915050610177565b5050505050565b6000806000806000808681526020019081526020016000206040518060600160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815250509050600073ffffffffffffffffffffffffffffffffffffffff16816000015173ffffffffffffffffffffffffffffffffffffffff1603610423576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161041a906109ee565b60405180910390fd5b806000015181602001518260400151935093509350509193909250565b6104498161046f565b50565b6104558161046f565b50565b600082610465858461064d565b1490509392505050565b6000801b81036104b4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104ab90610a5a565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610558576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054f90610ac6565b60405180910390fd5b60405180606001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020014381526020014281525060008083815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155905050803373ffffffffffffffffffffffffffffffffffffffff167ffdb3bf667beac2c2ec43eb46591be8a61f3426d05a1e30c8a59ff6608bab00884342604051610642929190610968565b60405180910390a350565b60008082905060005b8451811015610692576106838286838151811061067657610675610939565b5b602002602001015161069d565b91508080600101915050610656565b508091505092915050565b60008183106106b5576106b082846106c8565b6106c0565b6106bf83836106c8565b5b905092915050565b600082600052816020526040600020905092915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f84011261070e5761070d6106e9565b5b8235905067ffffffffffffffff81111561072b5761072a6106ee565b5b602083019150836020820283011115610747576107466106f3565b5b9250929050565b6000819050919050565b6107618161074e565b811461076c57600080fd5b50565b60008135905061077e81610758565b92915050565b6000806000806060858703121561079e5761079d6106df565b5b600085013567ffffffffffffffff8111156107bc576107bb6106e4565b5b6107c8878288016106f8565b945094505060206107db8782880161076f565b92505060406107ec8782880161076f565b91505092959194509250565b60008115159050919050565b61080d816107f8565b82525050565b60006020820190506108286000830184610804565b92915050565b60008060208385031215610845576108446106df565b5b600083013567ffffffffffffffff811115610863576108626106e4565b5b61086f858286016106f8565b92509250509250929050565b600060208284031215610891576108906106df565b5b600061089f8482850161076f565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006108d3826108a8565b9050919050565b6108e3816108c8565b82525050565b6000819050919050565b6108fc816108e9565b82525050565b600060608201905061091760008301866108da565b61092460208301856108f3565b61093160408301846108f3565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060408201905061097d60008301856108f3565b61098a60208301846108f3565b9392505050565b600082825260208201905092915050565b7f46696c65416e63686f723a206e6f7420616e63686f7265640000000000000000600082015250565b60006109d8601883610991565b91506109e3826109a2565b602082019050919050565b60006020820190508181036000830152610a07816109cb565b9050919050565b7f46696c65416e63686f723a20696e76616c696420686173680000000000000000600082015250565b6000610a44601883610991565b9150610a4f82610a0e565b602082019050919050565b60006020820190508181036000830152610a7381610a37565b9050919050565b7f46696c65416e63686f723a20616c726561647920616e63686f72656400000000600082015250565b6000610ab0601c83610991565b9150610abb82610a7a565b602082019050919050565b60006020820190508181036000830152610adf81610aa3565b905091905056fea2646970667358221220beeb5065b6daedbc13f0982ee5fbe6096819cd0dd3d1b257aa6869dbabd01dcf64736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806349a359f71461005c57806373d2a9e61461008c5780637feb51d9146100a8578063c50b037b146100da578063d5ce53d5146100f6575b600080fd5b61007660048036038101906100719190610784565b610112565b6040516100839190610813565b60405180910390f35b6100a660048036038101906100a1919061082e565b61016a565b005b6100c260048036038101906100bd919061087b565b610321565b6040516100d193929190610902565b60405180910390f35b6100f460048036038101906100ef919061087b565b610440565b005b610110600480360381019061010b919061087b565b61044c565b005b6000610160858580806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f820116905080830192505050505050508484610458565b9050949350505050565b6000439050600042905060005b8484905081101561031a57600085858381811061019757610196610939565b5b9050602002013590506000801b81141580156102145750600073ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b1561030c5760405180606001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018481525060008083815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155905050803373ffffffffffffffffffffffffffffffffffffffff167ffdb3bf667beac2c2ec43eb46591be8a61f3426d05a1e30c8a59ff6608bab00888686604051610303929190610968565b60405180910390a35b508080600101915050610177565b5050505050565b6000806000806000808681526020019081526020016000206040518060600160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015481526020016002820154815250509050600073ffffffffffffffffffffffffffffffffffffffff16816000015173ffffffffffffffffffffffffffffffffffffffff1603610423576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161041a906109ee565b60405180910390fd5b806000015181602001518260400151935093509350509193909250565b6104498161046f565b50565b6104558161046f565b50565b600082610465858461064d565b1490509392505050565b6000801b81036104b4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104ab90610a5a565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff1660008083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610558576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161054f90610ac6565b60405180910390fd5b60405180606001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020014381526020014281525060008083815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015560408201518160020155905050803373ffffffffffffffffffffffffffffffffffffffff167ffdb3bf667beac2c2ec43eb46591be8a61f3426d05a1e30c8a59ff6608bab00884342604051610642929190610968565b60405180910390a350565b60008082905060005b8451811015610692576106838286838151811061067657610675610939565b5b602002602001015161069d565b91508080600101915050610656565b508091505092915050565b60008183106106b5576106b082846106c8565b6106c0565b6106bf83836106c8565b5b905092915050565b600082600052816020526040600020905092915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f84011261070e5761070d6106e9565b5b8235905067ffffffffffffffff81111561072b5761072a6106ee565b5b602083019150836020820283011115610747576107466106f3565b5b9250929050565b6000819050919050565b6107618161074e565b811461076c57600080fd5b50565b60008135905061077e81610758565b92915050565b6000806000806060858703121561079e5761079d6106df565b5b600085013567ffffffffffffffff8111156107bc576107bb6106e4565b5b6107c8878288016106f8565b945094505060206107db8782880161076f565b92505060406107ec8782880161076f565b91505092959194509250565b60008115159050919050565b61080d816107f8565b82525050565b60006020820190506108286000830184610804565b92915050565b60008060208385031215610845576108446106df565b5b600083013567ffffffffffffffff811115610863576108626106e4565b5b61086f858286016106f8565b92509250509250929050565b600060208284031215610891576108906106df565b5b600061089f8482850161076f565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006108d3826108a8565b9050919050565b6108e3816108c8565b82525050565b6000819050919050565b6108fc816108e9565b82525050565b600060608201905061091760008301866108da565b61092460208301856108f3565b61093160408301846108f3565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600060408201905061097d60008301856108f3565b61098a60208301846108f3565b9392505050565b600082825260208201905092915050565b7f46696c65416e63686f723a206e6f7420616e63686f7265640000000000000000600082015250565b60006109d8601883610991565b91506109e3826109a2565b602082019050919050565b60006020820190508181036000830152610a07816109cb565b9050919050565b7f46696c65416e63686f723a20696e76616c696420686173680000000000000000600082015250565b6000610a44601883610991565b9150610a4f82610a0e565b602082019050919050565b60006020820190508181036000830152610a7381610a37565b9050919050565b7f46696c65416e63686f723a20616c726561647920616e63686f72656400000000600082015250565b6000610ab0601c83610991565b9150610abb82610a7a565b602082019050919050565b60006020820190508181036000830152610adf81610aa3565b905091905056fea2646970667358221220beeb5065b6daedbc13f0982ee5fbe6096819cd0dd3d1b257aa6869dbabd01dcf64736f6c634300081c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "FileAnchor",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "anchorBatch(bytes32[])": {
        "notice": "Anchor multiple hashes (leaves or roots) in one tx"
      },
      "anchorRoot(bytes32)": {
        "notice": "Anchor a Merkle root computed off-chain"
      },
      "anchorSingle(bytes32)": {
        "notice": "Anchor a single file-hash (keccak256 of the file)"
      },
      "getAnchor(bytes32)": {
        "notice": "Get who and when a hash/root was anchored"
      },
      "verifyInclusion(bytes32[],bytes32,bytes32)": {
        "notice": "Verifies that a leaf is in an anchored Merkle root"
      }
    },
    "notice": "Anchor single file hashes or Merkle roots on-chain, and verify inclusion proofs.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1128,
        "contract": "contracts/FileAnchor.sol:FileAnchor",
        "label": "_anchors",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_struct(AnchorData)1123_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_struct(AnchorData)1123_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct FileAnchor.AnchorData)",
        "numberOfBytes": "32",
        "value": "t_struct(AnchorData)1123_storage"
      },
      "t_struct(AnchorData)1123_storage": {
        "encoding": "inplace",
        "label": "struct FileAnchor.AnchorData",
        "members": [
          {
            "astId": 1118,
            "contract": "contracts/FileAnchor.sol:FileAnchor",
            "label": "uploader",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1120,
            "contract": "contracts/FileAnchor.sol:FileAnchor",
            "label": "blockNumber",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 1122,
            "contract": "contracts/FileAnchor.sol:FileAnchor",
            "label": "timestamp",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}